// Code generated by counterfeiter. DO NOT EDIT.
package mcpserverfakes

import (
	"sync"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/cmd/concourse-mcp/mcpserver"
	"github.com/concourse/concourse/go-concourse/concourse"
)

type FakeTeamAPI struct {
	CreateJobBuildStub        func(atc.PipelineRef, string) (atc.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		arg1 atc.PipelineRef
		arg2 string
	}
	createJobBuildReturns struct {
		result1 atc.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 atc.Build
		result2 error
	}
	CreateOrUpdatePipelineConfigStub        func(atc.PipelineRef, string, []byte, bool) (bool, bool, []concourse.ConfigWarning, error)
	createOrUpdatePipelineConfigMutex       sync.RWMutex
	createOrUpdatePipelineConfigArgsForCall []struct {
		arg1 atc.PipelineRef
		arg2 string
		arg3 []byte
		arg4 bool
	}
	createOrUpdatePipelineConfigReturns struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	createOrUpdatePipelineConfigReturnsOnCall map[int]struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}
	JobBuildsStub        func(atc.PipelineRef, string, concourse.Page) ([]atc.Build, concourse.Pagination, bool, error)
	jobBuildsMutex       sync.RWMutex
	jobBuildsArgsForCall []struct {
		arg1 atc.PipelineRef
		arg2 string
		arg3 concourse.Page
	}
	jobBuildsReturns struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	jobBuildsReturnsOnCall map[int]struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}
	ListJobsStub        func(atc.PipelineRef) ([]atc.Job, error)
	listJobsMutex       sync.RWMutex
	listJobsArgsForCall []struct {
		arg1 atc.PipelineRef
	}
	listJobsReturns struct {
		result1 []atc.Job
		result2 error
	}
	listJobsReturnsOnCall map[int]struct {
		result1 []atc.Job
		result2 error
	}
	ListPipelinesStub        func() ([]atc.Pipeline, error)
	listPipelinesMutex       sync.RWMutex
	listPipelinesArgsForCall []struct {
	}
	listPipelinesReturns struct {
		result1 []atc.Pipeline
		result2 error
	}
	listPipelinesReturnsOnCall map[int]struct {
		result1 []atc.Pipeline
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PausePipelineStub        func(atc.PipelineRef) (bool, error)
	pausePipelineMutex       sync.RWMutex
	pausePipelineArgsForCall []struct {
		arg1 atc.PipelineRef
	}
	pausePipelineReturns struct {
		result1 bool
		result2 error
	}
	pausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PipelineConfigStub        func(atc.PipelineRef) (atc.Config, string, bool, error)
	pipelineConfigMutex       sync.RWMutex
	pipelineConfigArgsForCall []struct {
		arg1 atc.PipelineRef
	}
	pipelineConfigReturns struct {
		result1 atc.Config
		result2 string
		result3 bool
		result4 error
	}
	pipelineConfigReturnsOnCall map[int]struct {
		result1 atc.Config
		result2 string
		result3 bool
		result4 error
	}
	UnpausePipelineStub        func(atc.PipelineRef) (bool, error)
	unpausePipelineMutex       sync.RWMutex
	unpausePipelineArgsForCall []struct {
		arg1 atc.PipelineRef
	}
	unpausePipelineReturns struct {
		result1 bool
		result2 error
	}
	unpausePipelineReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTeamAPI) CreateJobBuild(arg1 atc.PipelineRef, arg2 string) (atc.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		arg1 atc.PipelineRef
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateJobBuildStub
	fakeReturns := fake.createJobBuildReturns
	fake.recordInvocation("CreateJobBuild", []interface{}{arg1, arg2})
	fake.createJobBuildMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeamAPI) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakeTeamAPI) CreateJobBuildCalls(stub func(atc.PipelineRef, string) (atc.Build, error)) {
	fake.createJobBuildMutex.Lock()
	defer fake.createJobBuildMutex.Unlock()
	fake.CreateJobBuildStub = stub
}

func (fake *FakeTeamAPI) CreateJobBuildArgsForCall(i int) (atc.PipelineRef, string) {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	argsForCall := fake.createJobBuildArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTeamAPI) CreateJobBuildReturns(result1 atc.Build, result2 error) {
	fake.createJobBuildMutex.Lock()
	defer fake.createJobBuildMutex.Unlock()
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) CreateJobBuildReturnsOnCall(i int, result1 atc.Build, result2 error) {
	fake.createJobBuildMutex.Lock()
	defer fake.createJobBuildMutex.Unlock()
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 atc.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 atc.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfig(arg1 atc.PipelineRef, arg2 string, arg3 []byte, arg4 bool) (bool, bool, []concourse.ConfigWarning, error) {
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.createOrUpdatePipelineConfigMutex.Lock()
	ret, specificReturn := fake.createOrUpdatePipelineConfigReturnsOnCall[len(fake.createOrUpdatePipelineConfigArgsForCall)]
	fake.createOrUpdatePipelineConfigArgsForCall = append(fake.createOrUpdatePipelineConfigArgsForCall, struct {
		arg1 atc.PipelineRef
		arg2 string
		arg3 []byte
		arg4 bool
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.CreateOrUpdatePipelineConfigStub
	fakeReturns := fake.createOrUpdatePipelineConfigReturns
	fake.recordInvocation("CreateOrUpdatePipelineConfig", []interface{}{arg1, arg2, arg3Copy, arg4})
	fake.createOrUpdatePipelineConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfigCallCount() int {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	return len(fake.createOrUpdatePipelineConfigArgsForCall)
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfigCalls(stub func(atc.PipelineRef, string, []byte, bool) (bool, bool, []concourse.ConfigWarning, error)) {
	fake.createOrUpdatePipelineConfigMutex.Lock()
	defer fake.createOrUpdatePipelineConfigMutex.Unlock()
	fake.CreateOrUpdatePipelineConfigStub = stub
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfigArgsForCall(i int) (atc.PipelineRef, string, []byte, bool) {
	fake.createOrUpdatePipelineConfigMutex.RLock()
	defer fake.createOrUpdatePipelineConfigMutex.RUnlock()
	argsForCall := fake.createOrUpdatePipelineConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfigReturns(result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.createOrUpdatePipelineConfigMutex.Lock()
	defer fake.createOrUpdatePipelineConfigMutex.Unlock()
	fake.CreateOrUpdatePipelineConfigStub = nil
	fake.createOrUpdatePipelineConfigReturns = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) CreateOrUpdatePipelineConfigReturnsOnCall(i int, result1 bool, result2 bool, result3 []concourse.ConfigWarning, result4 error) {
	fake.createOrUpdatePipelineConfigMutex.Lock()
	defer fake.createOrUpdatePipelineConfigMutex.Unlock()
	fake.CreateOrUpdatePipelineConfigStub = nil
	if fake.createOrUpdatePipelineConfigReturnsOnCall == nil {
		fake.createOrUpdatePipelineConfigReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 bool
			result3 []concourse.ConfigWarning
			result4 error
		})
	}
	fake.createOrUpdatePipelineConfigReturnsOnCall[i] = struct {
		result1 bool
		result2 bool
		result3 []concourse.ConfigWarning
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) JobBuilds(arg1 atc.PipelineRef, arg2 string, arg3 concourse.Page) ([]atc.Build, concourse.Pagination, bool, error) {
	fake.jobBuildsMutex.Lock()
	ret, specificReturn := fake.jobBuildsReturnsOnCall[len(fake.jobBuildsArgsForCall)]
	fake.jobBuildsArgsForCall = append(fake.jobBuildsArgsForCall, struct {
		arg1 atc.PipelineRef
		arg2 string
		arg3 concourse.Page
	}{arg1, arg2, arg3})
	stub := fake.JobBuildsStub
	fakeReturns := fake.jobBuildsReturns
	fake.recordInvocation("JobBuilds", []interface{}{arg1, arg2, arg3})
	fake.jobBuildsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeamAPI) JobBuildsCallCount() int {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	return len(fake.jobBuildsArgsForCall)
}

func (fake *FakeTeamAPI) JobBuildsCalls(stub func(atc.PipelineRef, string, concourse.Page) ([]atc.Build, concourse.Pagination, bool, error)) {
	fake.jobBuildsMutex.Lock()
	defer fake.jobBuildsMutex.Unlock()
	fake.JobBuildsStub = stub
}

func (fake *FakeTeamAPI) JobBuildsArgsForCall(i int) (atc.PipelineRef, string, concourse.Page) {
	fake.jobBuildsMutex.RLock()
	defer fake.jobBuildsMutex.RUnlock()
	argsForCall := fake.jobBuildsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTeamAPI) JobBuildsReturns(result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.jobBuildsMutex.Lock()
	defer fake.jobBuildsMutex.Unlock()
	fake.JobBuildsStub = nil
	fake.jobBuildsReturns = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) JobBuildsReturnsOnCall(i int, result1 []atc.Build, result2 concourse.Pagination, result3 bool, result4 error) {
	fake.jobBuildsMutex.Lock()
	defer fake.jobBuildsMutex.Unlock()
	fake.JobBuildsStub = nil
	if fake.jobBuildsReturnsOnCall == nil {
		fake.jobBuildsReturnsOnCall = make(map[int]struct {
			result1 []atc.Build
			result2 concourse.Pagination
			result3 bool
			result4 error
		})
	}
	fake.jobBuildsReturnsOnCall[i] = struct {
		result1 []atc.Build
		result2 concourse.Pagination
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) ListJobs(arg1 atc.PipelineRef) ([]atc.Job, error) {
	fake.listJobsMutex.Lock()
	ret, specificReturn := fake.listJobsReturnsOnCall[len(fake.listJobsArgsForCall)]
	fake.listJobsArgsForCall = append(fake.listJobsArgsForCall, struct {
		arg1 atc.PipelineRef
	}{arg1})
	stub := fake.ListJobsStub
	fakeReturns := fake.listJobsReturns
	fake.recordInvocation("ListJobs", []interface{}{arg1})
	fake.listJobsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeamAPI) ListJobsCallCount() int {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return len(fake.listJobsArgsForCall)
}

func (fake *FakeTeamAPI) ListJobsCalls(stub func(atc.PipelineRef) ([]atc.Job, error)) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = stub
}

func (fake *FakeTeamAPI) ListJobsArgsForCall(i int) atc.PipelineRef {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	argsForCall := fake.listJobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeamAPI) ListJobsReturns(result1 []atc.Job, result2 error) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	fake.listJobsReturns = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) ListJobsReturnsOnCall(i int, result1 []atc.Job, result2 error) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	if fake.listJobsReturnsOnCall == nil {
		fake.listJobsReturnsOnCall = make(map[int]struct {
			result1 []atc.Job
			result2 error
		})
	}
	fake.listJobsReturnsOnCall[i] = struct {
		result1 []atc.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) ListPipelines() ([]atc.Pipeline, error) {
	fake.listPipelinesMutex.Lock()
	ret, specificReturn := fake.listPipelinesReturnsOnCall[len(fake.listPipelinesArgsForCall)]
	fake.listPipelinesArgsForCall = append(fake.listPipelinesArgsForCall, struct {
	}{})
	stub := fake.ListPipelinesStub
	fakeReturns := fake.listPipelinesReturns
	fake.recordInvocation("ListPipelines", []interface{}{})
	fake.listPipelinesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeamAPI) ListPipelinesCallCount() int {
	fake.listPipelinesMutex.RLock()
	defer fake.listPipelinesMutex.RUnlock()
	return len(fake.listPipelinesArgsForCall)
}

func (fake *FakeTeamAPI) ListPipelinesCalls(stub func() ([]atc.Pipeline, error)) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = stub
}

func (fake *FakeTeamAPI) ListPipelinesReturns(result1 []atc.Pipeline, result2 error) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = nil
	fake.listPipelinesReturns = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) ListPipelinesReturnsOnCall(i int, result1 []atc.Pipeline, result2 error) {
	fake.listPipelinesMutex.Lock()
	defer fake.listPipelinesMutex.Unlock()
	fake.ListPipelinesStub = nil
	if fake.listPipelinesReturnsOnCall == nil {
		fake.listPipelinesReturnsOnCall = make(map[int]struct {
			result1 []atc.Pipeline
			result2 error
		})
	}
	fake.listPipelinesReturnsOnCall[i] = struct {
		result1 []atc.Pipeline
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeTeamAPI) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeTeamAPI) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeTeamAPI) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeamAPI) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeamAPI) PausePipeline(arg1 atc.PipelineRef) (bool, error) {
	fake.pausePipelineMutex.Lock()
	ret, specificReturn := fake.pausePipelineReturnsOnCall[len(fake.pausePipelineArgsForCall)]
	fake.pausePipelineArgsForCall = append(fake.pausePipelineArgsForCall, struct {
		arg1 atc.PipelineRef
	}{arg1})
	stub := fake.PausePipelineStub
	fakeReturns := fake.pausePipelineReturns
	fake.recordInvocation("PausePipeline", []interface{}{arg1})
	fake.pausePipelineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeamAPI) PausePipelineCallCount() int {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	return len(fake.pausePipelineArgsForCall)
}

func (fake *FakeTeamAPI) PausePipelineCalls(stub func(atc.PipelineRef) (bool, error)) {
	fake.pausePipelineMutex.Lock()
	defer fake.pausePipelineMutex.Unlock()
	fake.PausePipelineStub = stub
}

func (fake *FakeTeamAPI) PausePipelineArgsForCall(i int) atc.PipelineRef {
	fake.pausePipelineMutex.RLock()
	defer fake.pausePipelineMutex.RUnlock()
	argsForCall := fake.pausePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeamAPI) PausePipelineReturns(result1 bool, result2 error) {
	fake.pausePipelineMutex.Lock()
	defer fake.pausePipelineMutex.Unlock()
	fake.PausePipelineStub = nil
	fake.pausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) PausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.pausePipelineMutex.Lock()
	defer fake.pausePipelineMutex.Unlock()
	fake.PausePipelineStub = nil
	if fake.pausePipelineReturnsOnCall == nil {
		fake.pausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.pausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) PipelineConfig(arg1 atc.PipelineRef) (atc.Config, string, bool, error) {
	fake.pipelineConfigMutex.Lock()
	ret, specificReturn := fake.pipelineConfigReturnsOnCall[len(fake.pipelineConfigArgsForCall)]
	fake.pipelineConfigArgsForCall = append(fake.pipelineConfigArgsForCall, struct {
		arg1 atc.PipelineRef
	}{arg1})
	stub := fake.PipelineConfigStub
	fakeReturns := fake.pipelineConfigReturns
	fake.recordInvocation("PipelineConfig", []interface{}{arg1})
	fake.pipelineConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3, fakeReturns.result4
}

func (fake *FakeTeamAPI) PipelineConfigCallCount() int {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	return len(fake.pipelineConfigArgsForCall)
}

func (fake *FakeTeamAPI) PipelineConfigCalls(stub func(atc.PipelineRef) (atc.Config, string, bool, error)) {
	fake.pipelineConfigMutex.Lock()
	defer fake.pipelineConfigMutex.Unlock()
	fake.PipelineConfigStub = stub
}

func (fake *FakeTeamAPI) PipelineConfigArgsForCall(i int) atc.PipelineRef {
	fake.pipelineConfigMutex.RLock()
	defer fake.pipelineConfigMutex.RUnlock()
	argsForCall := fake.pipelineConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeamAPI) PipelineConfigReturns(result1 atc.Config, result2 string, result3 bool, result4 error) {
	fake.pipelineConfigMutex.Lock()
	defer fake.pipelineConfigMutex.Unlock()
	fake.PipelineConfigStub = nil
	fake.pipelineConfigReturns = struct {
		result1 atc.Config
		result2 string
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) PipelineConfigReturnsOnCall(i int, result1 atc.Config, result2 string, result3 bool, result4 error) {
	fake.pipelineConfigMutex.Lock()
	defer fake.pipelineConfigMutex.Unlock()
	fake.PipelineConfigStub = nil
	if fake.pipelineConfigReturnsOnCall == nil {
		fake.pipelineConfigReturnsOnCall = make(map[int]struct {
			result1 atc.Config
			result2 string
			result3 bool
			result4 error
		})
	}
	fake.pipelineConfigReturnsOnCall[i] = struct {
		result1 atc.Config
		result2 string
		result3 bool
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeTeamAPI) UnpausePipeline(arg1 atc.PipelineRef) (bool, error) {
	fake.unpausePipelineMutex.Lock()
	ret, specificReturn := fake.unpausePipelineReturnsOnCall[len(fake.unpausePipelineArgsForCall)]
	fake.unpausePipelineArgsForCall = append(fake.unpausePipelineArgsForCall, struct {
		arg1 atc.PipelineRef
	}{arg1})
	stub := fake.UnpausePipelineStub
	fakeReturns := fake.unpausePipelineReturns
	fake.recordInvocation("UnpausePipeline", []interface{}{arg1})
	fake.unpausePipelineMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeTeamAPI) UnpausePipelineCallCount() int {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	return len(fake.unpausePipelineArgsForCall)
}

func (fake *FakeTeamAPI) UnpausePipelineCalls(stub func(atc.PipelineRef) (bool, error)) {
	fake.unpausePipelineMutex.Lock()
	defer fake.unpausePipelineMutex.Unlock()
	fake.UnpausePipelineStub = stub
}

func (fake *FakeTeamAPI) UnpausePipelineArgsForCall(i int) atc.PipelineRef {
	fake.unpausePipelineMutex.RLock()
	defer fake.unpausePipelineMutex.RUnlock()
	argsForCall := fake.unpausePipelineArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeTeamAPI) UnpausePipelineReturns(result1 bool, result2 error) {
	fake.unpausePipelineMutex.Lock()
	defer fake.unpausePipelineMutex.Unlock()
	fake.UnpausePipelineStub = nil
	fake.unpausePipelineReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) UnpausePipelineReturnsOnCall(i int, result1 bool, result2 error) {
	fake.unpausePipelineMutex.Lock()
	defer fake.unpausePipelineMutex.Unlock()
	fake.UnpausePipelineStub = nil
	if fake.unpausePipelineReturnsOnCall == nil {
		fake.unpausePipelineReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unpausePipelineReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeTeamAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTeamAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mcpserver.TeamAPI = new(FakeTeamAPI)
