package schema

import (
	"fmt"
	"strings"
)

// CoverageStatus classifies how well a requirement is covered by tests.
type CoverageStatus string

const (
	CoverageCovered              CoverageStatus = "covered"
	CoveragePartial              CoverageStatus = "partial"
	CoverageUncoveredImplemented CoverageStatus = "uncovered_implemented"
	CoverageUncoveredBroken      CoverageStatus = "uncovered_broken"
	CoverageFailing              CoverageStatus = "failing"
)

var validCoverageStatuses = map[CoverageStatus]bool{
	CoverageCovered:              true,
	CoveragePartial:              true,
	CoverageUncoveredImplemented: true,
	CoverageUncoveredBroken:      true,
	CoverageFailing:              true,
}

// CoveragePoints returns the score contribution for a coverage status.
func (c CoverageStatus) CoveragePoints() float64 {
	switch c {
	case CoverageCovered:
		return 1.0
	case CoveragePartial:
		return 0.5
	case CoverageUncoveredImplemented:
		return 0.75
	default:
		return 0.0
	}
}

// RequirementResult describes the QA result for a single requirement.
type RequirementResult struct {
	ID             string         `json:"id"`
	Text           string         `json:"text"`
	Status         CoverageStatus `json:"status"`
	CoveragePoints float64        `json:"coverage_points"`
	ExistingTests  []ExistingTest `json:"existing_tests,omitempty"`
	GeneratedTests []GeneratedTest `json:"generated_tests,omitempty"`
	Notes          string         `json:"notes,omitempty"`
}

// ExistingTest represents a discovered test file matching a requirement.
type ExistingTest struct {
	File     string  `json:"file"`
	Function string  `json:"function"`
	Match    float64 `json:"match"` // 0.0â€“1.0 confidence
}

// GeneratedTest represents a test generated by the gap test generator.
type GeneratedTest struct {
	File    string `json:"file"`
	Name    string `json:"name"`
	Passed  bool   `json:"passed"`
	Output  string `json:"output,omitempty"`
}

// Gap describes an uncovered or failing requirement.
type Gap struct {
	RequirementID string `json:"requirement_id"`
	Severity      string `json:"severity"` // "high" or "medium"
	Description   string `json:"description"`
}

// QAScore represents the computed QA coverage score.
type QAScore struct {
	Value     float64 `json:"value"`
	Max       float64 `json:"max"`
	Pass      bool    `json:"pass"`
	Threshold float64 `json:"threshold"`
}

// QAMetadata captures context about the QA run.
type QAMetadata struct {
	SpecFile             string `json:"spec_file"`
	RequirementsTotal    int    `json:"requirements_total"`
	RequirementsCovered  int    `json:"requirements_covered"`
	GeneratedTestsCount  int    `json:"generated_tests_count"`
	BrowserPlanGenerated bool   `json:"browser_plan_generated"`
}

// QAOutput is the top-level output schema for the QA agent.
type QAOutput struct {
	SchemaVersion string              `json:"schema_version"`
	Results       []RequirementResult `json:"results"`
	Score         QAScore             `json:"score"`
	Gaps          []Gap               `json:"gaps,omitempty"`
	BrowserPlan   string              `json:"browser_plan,omitempty"`
	Metadata      QAMetadata          `json:"metadata"`
}

// Validate checks that a QAOutput has all required fields.
func (q *QAOutput) Validate() error {
	if q.SchemaVersion == "" {
		q.SchemaVersion = "1.0.0"
	}

	for i, r := range q.Results {
		if r.ID == "" {
			return fmt.Errorf("result[%d]: id is required", i)
		}
		if strings.TrimSpace(r.Text) == "" {
			return fmt.Errorf("result[%d]: text is required", i)
		}
		if !validCoverageStatuses[r.Status] {
			return fmt.Errorf("result[%d]: invalid status %q", i, r.Status)
		}
	}

	if q.Score.Max <= 0 {
		return fmt.Errorf("score.max must be > 0")
	}

	return nil
}
