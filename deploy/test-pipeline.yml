resource_types:
- name: custom-time
  type: registry-image
  source:
    repository: concourse/time-resource

resources:
- name: trigger
  type: time
  source:
    interval: 5m

- name: custom-trigger
  type: custom-time
  source:
    interval: 10m

jobs:
- name: build-and-vet
  plan:
  - in_parallel:
    - get: trigger
      trigger: true
    - get: custom-trigger
  - task: build-and-vet
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          cd /src
          echo "=== Verifying full build ==="
          go build ./cmd/concourse/...
          echo "=== Build successful ==="
          echo ""
          echo "=== Running go vet ==="
          go vet ./atc/worker/jetbridge/... ./vars/... ./tsa/... ./tracing/... \
                 ./fly/commands/... ./fly/rc/... ./fly/eventstream/... \
                 ./atc/engine/... ./atc/resource/... \
                 ./atc/scheduler/... ./atc/metric/... ./atc/creds/... \
                 ./skymarshal/token/... ./skymarshal/skyserver/...
          echo "=== Vet passed ==="

- name: unit-tests
  plan:
  - get: trigger
    trigger: true
    passed: [build-and-vet]
  - task: unit-tests
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          cd /src
          echo "=== Running unit tests across the full codebase ==="
          echo "Excluding packages that require external infrastructure"
          echo ""
          PACKAGES=$(go list ./... \
            | grep -v /integration \
            | grep -v /testflight \
            | grep -v /topgun \
            | grep -v /fly/integration \
            | grep -v /atc/db \
            | grep -v /atc/gc \
            | grep -v /atc/postgresrunner \
            | grep -v /atc/scheduler/algorithm \
            | grep -v '/atc/worker$' \
            | grep -v /skymarshal/dexserver \
            | grep -v /cmd)
          echo "Testing packages:"
          echo "$PACKAGES" | head -20
          echo "... ($(echo "$PACKAGES" | wc -l | tr -d ' ') packages total)"
          echo ""
          go test -count=1 -timeout 10m $PACKAGES
          echo "=== All unit tests passed ==="

- name: k8s-runtime-tests
  serial: true
  plan:
  - get: trigger
    trigger: true
    passed: [unit-tests]
  - task: k8s-runtime-integration-tests
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          cd /src
          echo "=== Running jetbridge full test suite ==="
          go test -v -count=1 -timeout 5m ./atc/worker/jetbridge/...
          echo "=== All jetbridge tests passed ==="

- name: k8s-live-tests
  serial: true
  plan:
  - get: trigger
    trigger: true
    passed: [k8s-runtime-tests]
  - task: k8s-live-integration-tests
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          echo "=== Cleaning up stale test pods from previous runs ==="
          # Delete all live-* test pods (leaked from prior test runs)
          kubectl get pods -n concourse --no-headers -o custom-columns=":metadata.name" 2>/dev/null \
            | { grep '^live-' || true; } \
            | xargs -r kubectl delete pods -n concourse --grace-period=0 --force 2>/dev/null || true
          echo "Worker pods after cleanup:"
          kubectl get pods -n concourse -l concourse.ci/worker --no-headers 2>/dev/null | wc -l || true
          echo ""

          cd /src
          echo "=== Running jetbridge live integration tests ==="
          echo "These tests create real K8s pods against the live cluster."
          echo ""
          go test -tags live -v -count=1 -timeout 5m ./atc/worker/jetbridge/...
          echo "=== Live integration tests passed ==="

- name: build-image
  plan:
  - get: trigger
    trigger: true
    passed: [k8s-live-tests]
  - task: build-concourse-image
    privileged: true
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          cd /src
          echo "=== Building concourse binary ==="
          GOOS=linux GOARCH=arm64 go build -o concourse-linux-arm64 ./cmd/concourse
          ls -lh concourse-linux-arm64
          echo "=== Binary built ==="
          echo ""
          echo "=== Building Docker image ==="
          # Build the image using the cluster's container runtime.
          # This uses kubectl to create a builder pod that builds and
          # loads the image into the cluster's image cache.
          cat <<'DOCKERFILE' > /tmp/Dockerfile
          FROM ubuntu:22.04
          RUN apt-get update && \
              apt-get install -y ca-certificates dumb-init && \
              rm -rf /var/lib/apt/lists/*
          COPY concourse-linux-arm64 /usr/local/concourse/bin/concourse
          RUN chmod +x /usr/local/concourse/bin/concourse
          ENV PATH="/usr/local/concourse/bin:${PATH}"
          ENTRYPOINT ["dumb-init", "concourse"]
          DOCKERFILE

          echo "Binary and Dockerfile ready for image build."
          echo "Image build depends on cluster runtime (containerd/docker)."
          echo "=== Build artifacts prepared ==="

- name: deploy
  plan:
  - get: trigger
    trigger: true
    passed: [build-image]
  - task: deploy
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          echo "=== All tests passed â€” verifying deployment ==="
          echo ""
          echo "Checking concourse-web is running..."
          kubectl wait --for=condition=ready pod -l app=concourse-web -n concourse --timeout=60s
          echo ""
          echo "Current concourse-web pod:"
          kubectl get pods -n concourse -l app=concourse-web
          echo ""
          echo "=== Deploy verification complete ==="
          echo "Note: actual rollout restart is done out-of-band to avoid"
          echo "killing the ATC that is running this build."

- name: post-deploy-verify
  plan:
  - get: trigger
    trigger: true
    passed: [deploy]
  - task: verify-deployment
    config:
      platform: linux
      rootfs_uri: docker:///concourse-test-runner:v3
      run:
        path: sh
        args:
        - -exc
        - |
          echo "=== Post-deploy verification ==="
          echo ""
          echo "Checking concourse-web pod is running..."
          kubectl wait --for=condition=ready pod -l app=concourse-web -n concourse --timeout=60s
          echo ""
          echo "Verifying new pod has security context applied..."
          SECURITY_CTX=$(kubectl get pods -n concourse -l app=concourse-web -o jsonpath='{.items[0].spec.securityContext}')
          echo "Pod security context: $SECURITY_CTX"
          echo ""
          echo "Verifying K8s runtime flags are accepted..."
          WEB_POD=$(kubectl get pods -n concourse -l app=concourse-web -o jsonpath='{.items[0].metadata.name}')
          kubectl logs "$WEB_POD" -n concourse --tail=20 | head -10
          echo ""
          echo "Running post-deploy live smoke tests..."
          cd /src
          go test -tags live -v -count=1 -timeout 3m -run "TestLiveSecureDefaults|TestLiveResourceLimitsQoS" ./atc/worker/jetbridge/...
          echo ""
          echo "Running lifecycle & hijack live tests..."
          go test -tags live -v -count=1 -timeout 5m -run "TestLiveWorkerPodSurvivesCompletion|TestLiveWorkerHijackExistingPod" ./atc/worker/jetbridge/...
          echo ""
          echo "Running volume passing live tests..."
          go test -tags live -v -count=1 -timeout 5m -run "TestLiveVolumePassing" ./atc/worker/jetbridge/...
          echo ""
          echo "=== Post-deploy verification complete ==="
