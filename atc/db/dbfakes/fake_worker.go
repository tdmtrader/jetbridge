// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"sync"
	"time"

	"github.com/concourse/concourse/atc"
	"github.com/concourse/concourse/atc/db"
)

type FakeWorker struct {
	ActiveContainersStub        func() int
	activeContainersMutex       sync.RWMutex
	activeContainersArgsForCall []struct {
	}
	activeContainersReturns struct {
		result1 int
	}
	activeContainersReturnsOnCall map[int]struct {
		result1 int
	}
	ActiveTasksStub        func() (int, error)
	activeTasksMutex       sync.RWMutex
	activeTasksArgsForCall []struct {
	}
	activeTasksReturns struct {
		result1 int
		result2 error
	}
	activeTasksReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ActiveVolumesStub        func() int
	activeVolumesMutex       sync.RWMutex
	activeVolumesArgsForCall []struct {
	}
	activeVolumesReturns struct {
		result1 int
	}
	activeVolumesReturnsOnCall map[int]struct {
		result1 int
	}
	CreateContainerStub        func(db.ContainerOwner, db.ContainerMetadata) (db.CreatingContainer, error)
	createContainerMutex       sync.RWMutex
	createContainerArgsForCall []struct {
		arg1 db.ContainerOwner
		arg2 db.ContainerMetadata
	}
	createContainerReturns struct {
		result1 db.CreatingContainer
		result2 error
	}
	createContainerReturnsOnCall map[int]struct {
		result1 db.CreatingContainer
		result2 error
	}
	DeleteStub        func() error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	EphemeralStub        func() bool
	ephemeralMutex       sync.RWMutex
	ephemeralArgsForCall []struct {
	}
	ephemeralReturns struct {
		result1 bool
	}
	ephemeralReturnsOnCall map[int]struct {
		result1 bool
	}
	ExpiresAtStub        func() time.Time
	expiresAtMutex       sync.RWMutex
	expiresAtArgsForCall []struct {
	}
	expiresAtReturns struct {
		result1 time.Time
	}
	expiresAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	FindContainerStub        func(db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error)
	findContainerMutex       sync.RWMutex
	findContainerArgsForCall []struct {
		arg1 db.ContainerOwner
	}
	findContainerReturns struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}
	findContainerReturnsOnCall map[int]struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PlatformStub        func() string
	platformMutex       sync.RWMutex
	platformArgsForCall []struct {
	}
	platformReturns struct {
		result1 string
	}
	platformReturnsOnCall map[int]struct {
		result1 string
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ResourceTypesStub        func() []atc.WorkerResourceType
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 []atc.WorkerResourceType
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 []atc.WorkerResourceType
	}
	StartTimeStub        func() time.Time
	startTimeMutex       sync.RWMutex
	startTimeArgsForCall []struct {
	}
	startTimeReturns struct {
		result1 time.Time
	}
	startTimeReturnsOnCall map[int]struct {
		result1 time.Time
	}
	StateStub        func() db.WorkerState
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 db.WorkerState
	}
	stateReturnsOnCall map[int]struct {
		result1 db.WorkerState
	}
	TagsStub        func() []string
	tagsMutex       sync.RWMutex
	tagsArgsForCall []struct {
	}
	tagsReturns struct {
		result1 []string
	}
	tagsReturnsOnCall map[int]struct {
		result1 []string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	VersionStub        func() *string
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
	}
	versionReturns struct {
		result1 *string
	}
	versionReturnsOnCall map[int]struct {
		result1 *string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeWorker) ActiveContainers() int {
	fake.activeContainersMutex.Lock()
	ret, specificReturn := fake.activeContainersReturnsOnCall[len(fake.activeContainersArgsForCall)]
	fake.activeContainersArgsForCall = append(fake.activeContainersArgsForCall, struct {
	}{})
	stub := fake.ActiveContainersStub
	fakeReturns := fake.activeContainersReturns
	fake.recordInvocation("ActiveContainers", []interface{}{})
	fake.activeContainersMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveContainersCallCount() int {
	fake.activeContainersMutex.RLock()
	defer fake.activeContainersMutex.RUnlock()
	return len(fake.activeContainersArgsForCall)
}

func (fake *FakeWorker) ActiveContainersCalls(stub func() int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = stub
}

func (fake *FakeWorker) ActiveContainersReturns(result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	fake.activeContainersReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveContainersReturnsOnCall(i int, result1 int) {
	fake.activeContainersMutex.Lock()
	defer fake.activeContainersMutex.Unlock()
	fake.ActiveContainersStub = nil
	if fake.activeContainersReturnsOnCall == nil {
		fake.activeContainersReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeContainersReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveTasks() (int, error) {
	fake.activeTasksMutex.Lock()
	ret, specificReturn := fake.activeTasksReturnsOnCall[len(fake.activeTasksArgsForCall)]
	fake.activeTasksArgsForCall = append(fake.activeTasksArgsForCall, struct {
	}{})
	stub := fake.ActiveTasksStub
	fakeReturns := fake.activeTasksReturns
	fake.recordInvocation("ActiveTasks", []interface{}{})
	fake.activeTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ActiveTasksCallCount() int {
	fake.activeTasksMutex.RLock()
	defer fake.activeTasksMutex.RUnlock()
	return len(fake.activeTasksArgsForCall)
}

func (fake *FakeWorker) ActiveTasksCalls(stub func() (int, error)) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = stub
}

func (fake *FakeWorker) ActiveTasksReturns(result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	fake.activeTasksReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveTasksReturnsOnCall(i int, result1 int, result2 error) {
	fake.activeTasksMutex.Lock()
	defer fake.activeTasksMutex.Unlock()
	fake.ActiveTasksStub = nil
	if fake.activeTasksReturnsOnCall == nil {
		fake.activeTasksReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.activeTasksReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ActiveVolumes() int {
	fake.activeVolumesMutex.Lock()
	ret, specificReturn := fake.activeVolumesReturnsOnCall[len(fake.activeVolumesArgsForCall)]
	fake.activeVolumesArgsForCall = append(fake.activeVolumesArgsForCall, struct {
	}{})
	stub := fake.ActiveVolumesStub
	fakeReturns := fake.activeVolumesReturns
	fake.recordInvocation("ActiveVolumes", []interface{}{})
	fake.activeVolumesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ActiveVolumesCallCount() int {
	fake.activeVolumesMutex.RLock()
	defer fake.activeVolumesMutex.RUnlock()
	return len(fake.activeVolumesArgsForCall)
}

func (fake *FakeWorker) ActiveVolumesCalls(stub func() int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = stub
}

func (fake *FakeWorker) ActiveVolumesReturns(result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	fake.activeVolumesReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) ActiveVolumesReturnsOnCall(i int, result1 int) {
	fake.activeVolumesMutex.Lock()
	defer fake.activeVolumesMutex.Unlock()
	fake.ActiveVolumesStub = nil
	if fake.activeVolumesReturnsOnCall == nil {
		fake.activeVolumesReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.activeVolumesReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) CreateContainer(arg1 db.ContainerOwner, arg2 db.ContainerMetadata) (db.CreatingContainer, error) {
	fake.createContainerMutex.Lock()
	ret, specificReturn := fake.createContainerReturnsOnCall[len(fake.createContainerArgsForCall)]
	fake.createContainerArgsForCall = append(fake.createContainerArgsForCall, struct {
		arg1 db.ContainerOwner
		arg2 db.ContainerMetadata
	}{arg1, arg2})
	stub := fake.CreateContainerStub
	fakeReturns := fake.createContainerReturns
	fake.recordInvocation("CreateContainer", []interface{}{arg1, arg2})
	fake.createContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) CreateContainerCallCount() int {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	return len(fake.createContainerArgsForCall)
}

func (fake *FakeWorker) CreateContainerCalls(stub func(db.ContainerOwner, db.ContainerMetadata) (db.CreatingContainer, error)) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = stub
}

func (fake *FakeWorker) CreateContainerArgsForCall(i int) (db.ContainerOwner, db.ContainerMetadata) {
	fake.createContainerMutex.RLock()
	defer fake.createContainerMutex.RUnlock()
	argsForCall := fake.createContainerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeWorker) CreateContainerReturns(result1 db.CreatingContainer, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	fake.createContainerReturns = struct {
		result1 db.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) CreateContainerReturnsOnCall(i int, result1 db.CreatingContainer, result2 error) {
	fake.createContainerMutex.Lock()
	defer fake.createContainerMutex.Unlock()
	fake.CreateContainerStub = nil
	if fake.createContainerReturnsOnCall == nil {
		fake.createContainerReturnsOnCall = make(map[int]struct {
			result1 db.CreatingContainer
			result2 error
		})
	}
	fake.createContainerReturnsOnCall[i] = struct {
		result1 db.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) Delete() error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
	}{})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeWorker) DeleteCalls(stub func() error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeWorker) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeWorker) Ephemeral() bool {
	fake.ephemeralMutex.Lock()
	ret, specificReturn := fake.ephemeralReturnsOnCall[len(fake.ephemeralArgsForCall)]
	fake.ephemeralArgsForCall = append(fake.ephemeralArgsForCall, struct {
	}{})
	stub := fake.EphemeralStub
	fakeReturns := fake.ephemeralReturns
	fake.recordInvocation("Ephemeral", []interface{}{})
	fake.ephemeralMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) EphemeralCallCount() int {
	fake.ephemeralMutex.RLock()
	defer fake.ephemeralMutex.RUnlock()
	return len(fake.ephemeralArgsForCall)
}

func (fake *FakeWorker) EphemeralCalls(stub func() bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = stub
}

func (fake *FakeWorker) EphemeralReturns(result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	fake.ephemeralReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) EphemeralReturnsOnCall(i int, result1 bool) {
	fake.ephemeralMutex.Lock()
	defer fake.ephemeralMutex.Unlock()
	fake.EphemeralStub = nil
	if fake.ephemeralReturnsOnCall == nil {
		fake.ephemeralReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.ephemeralReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeWorker) ExpiresAt() time.Time {
	fake.expiresAtMutex.Lock()
	ret, specificReturn := fake.expiresAtReturnsOnCall[len(fake.expiresAtArgsForCall)]
	fake.expiresAtArgsForCall = append(fake.expiresAtArgsForCall, struct {
	}{})
	stub := fake.ExpiresAtStub
	fakeReturns := fake.expiresAtReturns
	fake.recordInvocation("ExpiresAt", []interface{}{})
	fake.expiresAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ExpiresAtCallCount() int {
	fake.expiresAtMutex.RLock()
	defer fake.expiresAtMutex.RUnlock()
	return len(fake.expiresAtArgsForCall)
}

func (fake *FakeWorker) ExpiresAtCalls(stub func() time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = stub
}

func (fake *FakeWorker) ExpiresAtReturns(result1 time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = nil
	fake.expiresAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) ExpiresAtReturnsOnCall(i int, result1 time.Time) {
	fake.expiresAtMutex.Lock()
	defer fake.expiresAtMutex.Unlock()
	fake.ExpiresAtStub = nil
	if fake.expiresAtReturnsOnCall == nil {
		fake.expiresAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.expiresAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) FindContainer(arg1 db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error) {
	fake.findContainerMutex.Lock()
	ret, specificReturn := fake.findContainerReturnsOnCall[len(fake.findContainerArgsForCall)]
	fake.findContainerArgsForCall = append(fake.findContainerArgsForCall, struct {
		arg1 db.ContainerOwner
	}{arg1})
	stub := fake.FindContainerStub
	fakeReturns := fake.findContainerReturns
	fake.recordInvocation("FindContainer", []interface{}{arg1})
	fake.findContainerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeWorker) FindContainerCallCount() int {
	fake.findContainerMutex.RLock()
	defer fake.findContainerMutex.RUnlock()
	return len(fake.findContainerArgsForCall)
}

func (fake *FakeWorker) FindContainerCalls(stub func(db.ContainerOwner) (db.CreatingContainer, db.CreatedContainer, error)) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = stub
}

func (fake *FakeWorker) FindContainerArgsForCall(i int) db.ContainerOwner {
	fake.findContainerMutex.RLock()
	defer fake.findContainerMutex.RUnlock()
	argsForCall := fake.findContainerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeWorker) FindContainerReturns(result1 db.CreatingContainer, result2 db.CreatedContainer, result3 error) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = nil
	fake.findContainerReturns = struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) FindContainerReturnsOnCall(i int, result1 db.CreatingContainer, result2 db.CreatedContainer, result3 error) {
	fake.findContainerMutex.Lock()
	defer fake.findContainerMutex.Unlock()
	fake.FindContainerStub = nil
	if fake.findContainerReturnsOnCall == nil {
		fake.findContainerReturnsOnCall = make(map[int]struct {
			result1 db.CreatingContainer
			result2 db.CreatedContainer
			result3 error
		})
	}
	fake.findContainerReturnsOnCall[i] = struct {
		result1 db.CreatingContainer
		result2 db.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeWorker) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	stub := fake.NameStub
	fakeReturns := fake.nameReturns
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeWorker) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeWorker) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Platform() string {
	fake.platformMutex.Lock()
	ret, specificReturn := fake.platformReturnsOnCall[len(fake.platformArgsForCall)]
	fake.platformArgsForCall = append(fake.platformArgsForCall, struct {
	}{})
	stub := fake.PlatformStub
	fakeReturns := fake.platformReturns
	fake.recordInvocation("Platform", []interface{}{})
	fake.platformMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) PlatformCallCount() int {
	fake.platformMutex.RLock()
	defer fake.platformMutex.RUnlock()
	return len(fake.platformArgsForCall)
}

func (fake *FakeWorker) PlatformCalls(stub func() string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = stub
}

func (fake *FakeWorker) PlatformReturns(result1 string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = nil
	fake.platformReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) PlatformReturnsOnCall(i int, result1 string) {
	fake.platformMutex.Lock()
	defer fake.platformMutex.Unlock()
	fake.PlatformStub = nil
	if fake.platformReturnsOnCall == nil {
		fake.platformReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.platformReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	stub := fake.ReloadStub
	fakeReturns := fake.reloadReturns
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeWorker) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakeWorker) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakeWorker) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeWorker) ResourceTypes() []atc.WorkerResourceType {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	stub := fake.ResourceTypesStub
	fakeReturns := fake.resourceTypesReturns
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakeWorker) ResourceTypesCalls(stub func() []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakeWorker) ResourceTypesReturns(result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) ResourceTypesReturnsOnCall(i int, result1 []atc.WorkerResourceType) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 []atc.WorkerResourceType
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 []atc.WorkerResourceType
	}{result1}
}

func (fake *FakeWorker) StartTime() time.Time {
	fake.startTimeMutex.Lock()
	ret, specificReturn := fake.startTimeReturnsOnCall[len(fake.startTimeArgsForCall)]
	fake.startTimeArgsForCall = append(fake.startTimeArgsForCall, struct {
	}{})
	stub := fake.StartTimeStub
	fakeReturns := fake.startTimeReturns
	fake.recordInvocation("StartTime", []interface{}{})
	fake.startTimeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) StartTimeCallCount() int {
	fake.startTimeMutex.RLock()
	defer fake.startTimeMutex.RUnlock()
	return len(fake.startTimeArgsForCall)
}

func (fake *FakeWorker) StartTimeCalls(stub func() time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = stub
}

func (fake *FakeWorker) StartTimeReturns(result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	fake.startTimeReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) StartTimeReturnsOnCall(i int, result1 time.Time) {
	fake.startTimeMutex.Lock()
	defer fake.startTimeMutex.Unlock()
	fake.StartTimeStub = nil
	if fake.startTimeReturnsOnCall == nil {
		fake.startTimeReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.startTimeReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeWorker) State() db.WorkerState {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeWorker) StateCalls(stub func() db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeWorker) StateReturns(result1 db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 db.WorkerState
	}{result1}
}

func (fake *FakeWorker) StateReturnsOnCall(i int, result1 db.WorkerState) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 db.WorkerState
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 db.WorkerState
	}{result1}
}

func (fake *FakeWorker) Tags() []string {
	fake.tagsMutex.Lock()
	ret, specificReturn := fake.tagsReturnsOnCall[len(fake.tagsArgsForCall)]
	fake.tagsArgsForCall = append(fake.tagsArgsForCall, struct {
	}{})
	stub := fake.TagsStub
	fakeReturns := fake.tagsReturns
	fake.recordInvocation("Tags", []interface{}{})
	fake.tagsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TagsCallCount() int {
	fake.tagsMutex.RLock()
	defer fake.tagsMutex.RUnlock()
	return len(fake.tagsArgsForCall)
}

func (fake *FakeWorker) TagsCalls(stub func() []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = stub
}

func (fake *FakeWorker) TagsReturns(result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	fake.tagsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeWorker) TagsReturnsOnCall(i int, result1 []string) {
	fake.tagsMutex.Lock()
	defer fake.tagsMutex.Unlock()
	fake.TagsStub = nil
	if fake.tagsReturnsOnCall == nil {
		fake.tagsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.tagsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeWorker) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	stub := fake.TeamIDStub
	fakeReturns := fake.teamIDReturns
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakeWorker) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakeWorker) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeWorker) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	stub := fake.TeamNameStub
	fakeReturns := fake.teamNameReturns
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakeWorker) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakeWorker) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeWorker) Version() *string {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
	}{})
	stub := fake.VersionStub
	fakeReturns := fake.versionReturns
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeWorker) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeWorker) VersionCalls(stub func() *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeWorker) VersionReturns(result1 *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) VersionReturnsOnCall(i int, result1 *string) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeWorker) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeWorker) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Worker = new(FakeWorker)
